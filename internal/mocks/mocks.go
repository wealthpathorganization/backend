// Code generated by manual mock creation. DO NOT EDIT.
// Mimics mockery-style mocks for repository interfaces.

package mocks

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
	"github.com/stretchr/testify/mock"
	"github.com/wealthpath/backend/internal/model"
	"github.com/wealthpath/backend/internal/repository"
)

// UserRepositoryInterface mock
type UserRepositoryInterface struct {
	mock.Mock
}

func (m *UserRepositoryInterface) Create(ctx context.Context, user *model.User) error {
	ret := m.Called(ctx, user)
	return ret.Error(0)
}

func (m *UserRepositoryInterface) GetByID(ctx context.Context, id uuid.UUID) (*model.User, error) {
	ret := m.Called(ctx, id)
	var r0 *model.User
	if ret.Get(0) != nil {
		r0 = ret.Get(0).(*model.User)
	}
	return r0, ret.Error(1)
}

func (m *UserRepositoryInterface) GetByEmail(ctx context.Context, email string) (*model.User, error) {
	ret := m.Called(ctx, email)
	var r0 *model.User
	if ret.Get(0) != nil {
		r0 = ret.Get(0).(*model.User)
	}
	return r0, ret.Error(1)
}

func (m *UserRepositoryInterface) GetByOAuth(ctx context.Context, provider, oauthID string) (*model.User, error) {
	ret := m.Called(ctx, provider, oauthID)
	var r0 *model.User
	if ret.Get(0) != nil {
		r0 = ret.Get(0).(*model.User)
	}
	return r0, ret.Error(1)
}

func (m *UserRepositoryInterface) EmailExists(ctx context.Context, email string) (bool, error) {
	ret := m.Called(ctx, email)
	return ret.Bool(0), ret.Error(1)
}

func (m *UserRepositoryInterface) Update(ctx context.Context, user *model.User) error {
	ret := m.Called(ctx, user)
	return ret.Error(0)
}

// TransactionRepositoryInterface mock
type TransactionRepositoryInterface struct {
	mock.Mock
}

func (m *TransactionRepositoryInterface) Create(ctx context.Context, tx *model.Transaction) error {
	ret := m.Called(ctx, tx)
	return ret.Error(0)
}

func (m *TransactionRepositoryInterface) GetByID(ctx context.Context, id uuid.UUID) (*model.Transaction, error) {
	ret := m.Called(ctx, id)
	var r0 *model.Transaction
	if ret.Get(0) != nil {
		r0 = ret.Get(0).(*model.Transaction)
	}
	return r0, ret.Error(1)
}

func (m *TransactionRepositoryInterface) List(ctx context.Context, userID uuid.UUID, filters repository.TransactionFilters) ([]model.Transaction, error) {
	ret := m.Called(ctx, userID, filters)
	var r0 []model.Transaction
	if ret.Get(0) != nil {
		r0 = ret.Get(0).([]model.Transaction)
	}
	return r0, ret.Error(1)
}

func (m *TransactionRepositoryInterface) Update(ctx context.Context, tx *model.Transaction) error {
	ret := m.Called(ctx, tx)
	return ret.Error(0)
}

func (m *TransactionRepositoryInterface) Delete(ctx context.Context, id, userID uuid.UUID) error {
	ret := m.Called(ctx, id, userID)
	return ret.Error(0)
}

func (m *TransactionRepositoryInterface) GetMonthlyTotals(ctx context.Context, userID uuid.UUID, year, month int) (decimal.Decimal, decimal.Decimal, error) {
	ret := m.Called(ctx, userID, year, month)
	return ret.Get(0).(decimal.Decimal), ret.Get(1).(decimal.Decimal), ret.Error(2)
}

func (m *TransactionRepositoryInterface) GetExpensesByCategory(ctx context.Context, userID uuid.UUID, startDate, endDate time.Time) (map[string]decimal.Decimal, error) {
	ret := m.Called(ctx, userID, startDate, endDate)
	var r0 map[string]decimal.Decimal
	if ret.Get(0) != nil {
		r0 = ret.Get(0).(map[string]decimal.Decimal)
	}
	return r0, ret.Error(1)
}

func (m *TransactionRepositoryInterface) GetSpentByCategory(ctx context.Context, userID uuid.UUID, category string, startDate, endDate time.Time) (decimal.Decimal, error) {
	ret := m.Called(ctx, userID, category, startDate, endDate)
	return ret.Get(0).(decimal.Decimal), ret.Error(1)
}

func (m *TransactionRepositoryInterface) GetRecentTransactions(ctx context.Context, userID uuid.UUID, limit int) ([]model.Transaction, error) {
	ret := m.Called(ctx, userID, limit)
	var r0 []model.Transaction
	if ret.Get(0) != nil {
		r0 = ret.Get(0).([]model.Transaction)
	}
	return r0, ret.Error(1)
}

func (m *TransactionRepositoryInterface) GetMonthlyComparison(ctx context.Context, userID uuid.UUID, months int) ([]model.MonthlyComparison, error) {
	ret := m.Called(ctx, userID, months)
	var r0 []model.MonthlyComparison
	if ret.Get(0) != nil {
		r0 = ret.Get(0).([]model.MonthlyComparison)
	}
	return r0, ret.Error(1)
}

// BudgetRepositoryInterface mock
type BudgetRepositoryInterface struct {
	mock.Mock
}

func (m *BudgetRepositoryInterface) Create(ctx context.Context, budget *model.Budget) error {
	ret := m.Called(ctx, budget)
	return ret.Error(0)
}

func (m *BudgetRepositoryInterface) GetByID(ctx context.Context, id uuid.UUID) (*model.Budget, error) {
	ret := m.Called(ctx, id)
	var r0 *model.Budget
	if ret.Get(0) != nil {
		r0 = ret.Get(0).(*model.Budget)
	}
	return r0, ret.Error(1)
}

func (m *BudgetRepositoryInterface) List(ctx context.Context, userID uuid.UUID) ([]model.Budget, error) {
	ret := m.Called(ctx, userID)
	var r0 []model.Budget
	if ret.Get(0) != nil {
		r0 = ret.Get(0).([]model.Budget)
	}
	return r0, ret.Error(1)
}

func (m *BudgetRepositoryInterface) GetActiveForUser(ctx context.Context, userID uuid.UUID) ([]model.Budget, error) {
	ret := m.Called(ctx, userID)
	var r0 []model.Budget
	if ret.Get(0) != nil {
		r0 = ret.Get(0).([]model.Budget)
	}
	return r0, ret.Error(1)
}

func (m *BudgetRepositoryInterface) Update(ctx context.Context, budget *model.Budget) error {
	ret := m.Called(ctx, budget)
	return ret.Error(0)
}

func (m *BudgetRepositoryInterface) Delete(ctx context.Context, id, userID uuid.UUID) error {
	ret := m.Called(ctx, id, userID)
	return ret.Error(0)
}

// DebtRepositoryInterface mock
type DebtRepositoryInterface struct {
	mock.Mock
}

func (m *DebtRepositoryInterface) Create(ctx context.Context, debt *model.Debt) error {
	ret := m.Called(ctx, debt)
	return ret.Error(0)
}

func (m *DebtRepositoryInterface) GetByID(ctx context.Context, id uuid.UUID) (*model.Debt, error) {
	ret := m.Called(ctx, id)
	var r0 *model.Debt
	if ret.Get(0) != nil {
		r0 = ret.Get(0).(*model.Debt)
	}
	return r0, ret.Error(1)
}

func (m *DebtRepositoryInterface) List(ctx context.Context, userID uuid.UUID) ([]model.Debt, error) {
	ret := m.Called(ctx, userID)
	var r0 []model.Debt
	if ret.Get(0) != nil {
		r0 = ret.Get(0).([]model.Debt)
	}
	return r0, ret.Error(1)
}

func (m *DebtRepositoryInterface) Update(ctx context.Context, debt *model.Debt) error {
	ret := m.Called(ctx, debt)
	return ret.Error(0)
}

func (m *DebtRepositoryInterface) Delete(ctx context.Context, id, userID uuid.UUID) error {
	ret := m.Called(ctx, id, userID)
	return ret.Error(0)
}

func (m *DebtRepositoryInterface) RecordPayment(ctx context.Context, payment *model.DebtPayment) error {
	ret := m.Called(ctx, payment)
	return ret.Error(0)
}

func (m *DebtRepositoryInterface) GetTotalDebt(ctx context.Context, userID uuid.UUID) (decimal.Decimal, error) {
	ret := m.Called(ctx, userID)
	return ret.Get(0).(decimal.Decimal), ret.Error(1)
}

// SavingsGoalRepositoryInterface mock
type SavingsGoalRepositoryInterface struct {
	mock.Mock
}

func (m *SavingsGoalRepositoryInterface) Create(ctx context.Context, goal *model.SavingsGoal) error {
	ret := m.Called(ctx, goal)
	return ret.Error(0)
}

func (m *SavingsGoalRepositoryInterface) GetByID(ctx context.Context, id uuid.UUID) (*model.SavingsGoal, error) {
	ret := m.Called(ctx, id)
	var r0 *model.SavingsGoal
	if ret.Get(0) != nil {
		r0 = ret.Get(0).(*model.SavingsGoal)
	}
	return r0, ret.Error(1)
}

func (m *SavingsGoalRepositoryInterface) List(ctx context.Context, userID uuid.UUID) ([]model.SavingsGoal, error) {
	ret := m.Called(ctx, userID)
	var r0 []model.SavingsGoal
	if ret.Get(0) != nil {
		r0 = ret.Get(0).([]model.SavingsGoal)
	}
	return r0, ret.Error(1)
}

func (m *SavingsGoalRepositoryInterface) Update(ctx context.Context, goal *model.SavingsGoal) error {
	ret := m.Called(ctx, goal)
	return ret.Error(0)
}

func (m *SavingsGoalRepositoryInterface) Delete(ctx context.Context, id, userID uuid.UUID) error {
	ret := m.Called(ctx, id, userID)
	return ret.Error(0)
}

func (m *SavingsGoalRepositoryInterface) AddContribution(ctx context.Context, id, userID uuid.UUID, amount decimal.Decimal) error {
	ret := m.Called(ctx, id, userID, amount)
	return ret.Error(0)
}

func (m *SavingsGoalRepositoryInterface) GetTotalSavings(ctx context.Context, userID uuid.UUID) (decimal.Decimal, error) {
	ret := m.Called(ctx, userID)
	return ret.Get(0).(decimal.Decimal), ret.Error(1)
}

// RecurringRepositoryInterface mock
type RecurringRepositoryInterface struct {
	mock.Mock
}

func (m *RecurringRepositoryInterface) Create(ctx context.Context, rt *model.RecurringTransaction) error {
	ret := m.Called(ctx, rt)
	return ret.Error(0)
}

func (m *RecurringRepositoryInterface) GetByID(ctx context.Context, id uuid.UUID) (*model.RecurringTransaction, error) {
	ret := m.Called(ctx, id)
	var r0 *model.RecurringTransaction
	if ret.Get(0) != nil {
		r0 = ret.Get(0).(*model.RecurringTransaction)
	}
	return r0, ret.Error(1)
}

func (m *RecurringRepositoryInterface) GetByUserID(ctx context.Context, userID uuid.UUID) ([]model.RecurringTransaction, error) {
	ret := m.Called(ctx, userID)
	var r0 []model.RecurringTransaction
	if ret.Get(0) != nil {
		r0 = ret.Get(0).([]model.RecurringTransaction)
	}
	return r0, ret.Error(1)
}

func (m *RecurringRepositoryInterface) Update(ctx context.Context, rt *model.RecurringTransaction) error {
	ret := m.Called(ctx, rt)
	return ret.Error(0)
}

func (m *RecurringRepositoryInterface) Delete(ctx context.Context, id uuid.UUID) error {
	ret := m.Called(ctx, id)
	return ret.Error(0)
}

func (m *RecurringRepositoryInterface) GetUpcoming(ctx context.Context, userID uuid.UUID, limit int) ([]model.UpcomingBill, error) {
	ret := m.Called(ctx, userID, limit)
	var r0 []model.UpcomingBill
	if ret.Get(0) != nil {
		r0 = ret.Get(0).([]model.UpcomingBill)
	}
	return r0, ret.Error(1)
}

func (m *RecurringRepositoryInterface) GetDueTransactions(ctx context.Context, now time.Time) ([]model.RecurringTransaction, error) {
	ret := m.Called(ctx, now)
	var r0 []model.RecurringTransaction
	if ret.Get(0) != nil {
		r0 = ret.Get(0).([]model.RecurringTransaction)
	}
	return r0, ret.Error(1)
}

func (m *RecurringRepositoryInterface) UpdateLastGenerated(ctx context.Context, id uuid.UUID, lastGenerated, nextOccurrence time.Time) error {
	ret := m.Called(ctx, id, lastGenerated, nextOccurrence)
	return ret.Error(0)
}
